"""
Classes that represent various types of input files
"""
class AmberMdin:
    def __init__(self, cut=9.0, ioutfm=1, ntb=1, ntxo=2):
        # to store blocks of functions
        self.blocks = []
        self.apply_defaults(cut=cut, ioutfm=ioutfm, ntb=ntb, ntxo=ntxo)

    def add_block(self, name, params=None):
        name = name.strip('&')
        self.blocks.append({'type': 'block',
                            'name': name,
                            'params': params or {}})

    def add_raw(self, line):
        self.blocks.append({'type': 'raw',
                            'line': line.strip()})
        
    def update_param(self, block_name, key, value):
        for block in self.blocks:
            if block['type'] == 'block' and block['name'] == block_name:
                block['params'][key] = value
                return
        raise KeyError(f"Block '{block_name}' not found")
    
    def override_block(self, block_name, param_dict):
        found = False
        for block in self.blocks:
            if block['type'] == 'block' and block['name'] == block_name:
                block['params'].update(param_dict)
                found = True
        if not found:
            self.add_block(block_name, param_dict)

    def to_string(self) -> str:
        lines = []
        for block in self.blocks:
            if block['type'] == 'block':
                lines.append(f" &{block['name']}")
                for k, v in block['params'].items():
                    lines.append(f"  {k} = {v},")
                lines.append(" /")
            elif block['type'] == 'raw':
                lines.append(block['line'])
        return "\n".join(lines)

    def save(self, filename: str):
        with open(filename, 'w') as f:
            f.write("# This file was generated by AmberMdin class\n")
            f.write(self.to_string())

    def apply_defaults(self, cut=9.0, ioutfm=1, ntb=1, ntxo=2):
        self.add_block("cntrl", {
            # no minimization
            "imin": 0,
            # no restart
            "irest": 0,
            # no read velocity
            "ntx": 1,
            # write binary NC restart
            "ntxo": ntxo,
            # shake 
            "ntf": 2,
            # H-bond constraints
            "ntc": 2,
            # cutoff distance
            "cut": cut,
            # output frequency
            "ntpr": 5000,
            "ntwr": 5000,
            "ntwx": 5000,
            # wrap coordinates
            "iwrap": 1,
            # binary output
            "ioutfm": ioutfm,
            # periodic boundary conditions
            "ntb": ntb,
        })


def apply_minimization(mdin: AmberMdin, steps=5000):
    mdin.override_block("cntrl", {
        "imin": 1,
        "maxcyc": steps,
        # switch from steepest descent to conjugate gradient after half the steps
        "ncyc": steps // 2,
    })


def apply_npt(mdin: AmberMdin, temp=310, steps=50000, barostat=2, dt=0.004):
    mdin.override_block("cntrl", {
        "ntp": 1,
        "barostat": barostat,
        # langevin thermostat
        "ntt": 3,
        "temp0": temp,
        "gamma_ln": 1.0,
        "nstlim": steps,
        "dt": dt,
    })

def apply_membrane_npt(mdin: AmberMdin, temp=310, steps=50000, barostat=2, dt=0.004):
    mdin.override_block("cntrl", {
        "ntp": 3,
        "barostat": barostat,
        "csurften": 3
        # langevin thermostat
        "ntt": 3,
        "temp0": temp,
        "gamma_ln": 1.0,
        "nstlim": steps,
        "dt": dt,
    })


def apply_ti(mdin: AmberMdin, lbd_val, timask1, timask2, scmask1, scmask2, crgmask):
    mdin.override_block("cntrl", {
        "icfe": 1,
        "clambda": lbd_val,
        "timask1": f"'{timask1}'",
        "timask2": f"'{timask2}'",
        "scmask1": f"'{scmask1}'",
        "scmask2": f"'{scmask2}'",
        "crgmask": f"'{crgmask}'",
        "ifsc": 1,
        "ifmbar": 1,
    })


def apply_restraints(mdin: AmberMdin, mask: str, weight: float = 50.0):
    mdin.override_block("cntrl", {
        "ntr": 1,
        "restraintmask": f"'{mask}'",
        "restraint_wt": weight,
    })


def apply_wt_end(mdin: AmberMdin):
    mdin.add_raw("&wt type='END', /")


def apply_disang(mdin: AmberMdin, filename="disang.rest"):
    mdin.add_raw(f"DISANG={filename}")
    mdin.add_raw("LISTOUT=POUT")